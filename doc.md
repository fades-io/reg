Для того, чтобы осуществялять регистрацию новых пользователей в приложение предусмотрен микросервис регистрации. 
Он принимает следующие данные в строковом формате:
* логин
* электронную почту
* пароль

После этого в базу данных вносится новый пользователь.
Затем он сможет пользоваться приложением, в том числе получать токен для доступа к содержимому, проходить тесты и вести собственную статистику.

# Запуск микросервиса
Код для запуска приложения хранится в папке cmd.
В ней содержится файл main.go который будет исполняться при запуске микросервиса.
Там содержится функция main() которая является корневой для любой программы, написанной на языке Go.
Указанная функция сначала загружает значения из файла .env в котором содержатся параметры запуска микросервиса, такие как:
* адрес хоста
* прослушиваемый порт
* адрес хоста базы данных
* порт базы данных
* драйвер базы данных
* данные пользователя базы данных

Затем осуществялется запуск с помощью функции Run().
Она создает и запускает сервер.
# Подключение к БД
При запуске микросервиса сначала конфигурируется подключение к базе данных.
Конфигурация имеет следущий вид:
```
type DbConfig struct {
	driver   string
	host     string
	port     string
	name     string
	user     string
	password string
}
```
В данную структуру передаются значения из .env файла.
Затем происходит подключение к базе данных и создается объект хранилища.
После этого сервер инициализируется данным хранилищем.

# Структура сервера
Сервер имеет структуру
```
type Server struct {
	service Service
	Router  *httprouter.Router
}
```
Для инициализации сервера необходимо создать сервис и роутер.
# Инициализация сервиса
Cервис содержит тип Storage, который является интерфейсом для работы с базой данных и, в частности, для регистрации нового пользователя.
Он обращается к сервису для работы с БД и вызывает у него метод RegUser().
Реализация этого метода содержится в файле postgresql.go.
В этом файле инкапсулирована вся логика работы с базой данных.
База данных с которой связан микросервис находится под управлением системы управления базами данных PostgreSQL.
Непосредственная работа с базой данных происходит с помощью библиотеки GORM.
В ней используется технология программирования, связывающая базы данных с объектами в программе.
Такой объект, представляющие данные о новом пользоателе, который собирается зарегистрироваться в приложении, содержится в доменной области программы и имеет следующий вид:
```
type UserToDB struct {
	ID       uint32
	Username string
	Email    string
	Password string
}
```
Процесс добавления пользователя в базу данных приложения происходит с помощью команды:
`Create(&domain.UserToDB{Username: username, Email: email, Password: password})`

# Инициализация роутера
При инициализации сервера также создается объект роутера.
Задача роутера состоит в том, чтобы перехватывать и обрабатывать запросы по сети.
При инициализации роутеру нужно передать адаптер `HandlerFunc`, который позволит обрабатывать запросы.
Для этого передается метод, адрес и объект промежуточного слоя (middleware), который установит заголовки и обработает ошибки. Все такие объекты являются посредниками при запросах и хранятся в пакете middleware.go .
Это делается следующим образом:
`server.Router.HandlerFunc(http.MethodPost, userRegURL, middlewares.Middleware(server.Reg))`

# Обработка ошибок 
В пакете internal содержится пакет apperror. В нем содержится файл `apperror.go`. Он содержит сущности, которые отвечают за корректную обработку ошибок.
В приложении используется специальный тип `AppError`, который представляет достаточную информацию о возникшей ошибке.
Этот тип имеет следующую структуру:
```
type AppError struct {
	Err              error  `json:"-"`
	Message          string `json:"message,omitempty"`
	DeveloperMessage string `json:"developer_message,omitempty"`
	Code             uint32 `json:"code,omitempty"`
}
```
Таким образом каждая ошибка содержит 
- объект ошибки,
- сообщение,
- сообщение для разработчиков (которое может содержть более подрубную информацию),
- код ошибки для её уникальной идентификации.

Причем, последние перечисленные три поля необязательные, так как содержат тэг `omitempty`, который отвечает за то, чтобы исключить эти поля из структуры JSON если будет передано пустое значение.
Имеется функция создания новой ошибки, которая принимает объект ошибки, два строковых значения для простого сообщения  сообщения для разработчиков и код ошибки в кодировке `uint32`.
Она имеет следующий вид:
```
func NewAppError(err error, message, developerMessage string, code uint32) *AppError {
	return &AppError{
		Err:              err,
		Message:          message,
		DeveloperMessage: developerMessage,
		Code:             code,
	}
}
```

В данном файле имеется следующие вспомогательные методы.
- `Error()` - требуется для соответсвия стандартному интерфейсу ошибки
- `Unwrap()` - возвращает корневую ошибку
- `Marshal()` - помогает в сериализации ошибки. Сериализация — это преобразование объекта в массив байтов

Имеется метод возвращающий стандартную внутренню серверную ошибку:
```
func SystemError(err error) *AppError {
	return NewAppError(err, logs.InternalServerError, err.Error(), 418)
}
```

Также заведены переменные для удобного использования наиболее частых ошибок:
```
var (
	ErrNotFound = NewAppError(nil, logs.NotFound, "", 404)
)
```

Ответственность за обработку ошибок лежит на функции `HandleError()`
В ней обрабатываются все ошибки, который возвращает хэндлер.
Обработка ошибок проходит по следущему алгоритму:
1. Проверка на то, является ли эта ошибка специальной
 1.1. Если эта ошибка специальная проверяем, происходит проверка на то, оповещает ли эта ошибка о том что ресурс не найден.
 2.2 Любой другой исход означает то, что проблема вызвана некорректными пользовательскими данными.
2. Если ошибка не является специальной - необходимо обернуть её в системную.

При каждом исходе - устанавливаем Header с соответствующим кодом ошибки.
`w.WriteHeader(statusCode)`
